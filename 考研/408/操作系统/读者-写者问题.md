# 问题描述
- 可同时读,并不改变数据
- 不可同时写
- 不可以边读边写
![](attachments/%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%202022-09-25%2019.11.43.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%202022-09-25%2019.11.43.excalidraw.md)%%

# 问题分析
## 我的分析
- **互斥**
	- 不可以边读边写
		- 读者人数<1可以写
		- `s mutexr_w=1`
			- 每次读 mutex-1
			- 写的时候p(mutex)
	- 不可以边写边写
		- `s write=1`
- **同步**
- 读者:
	- 有人在写吗? P(mutexr_w)
	- 有人在读 v(reader)
		- 多个读者时会导致reader=5
		- 希望reader<1时才能写 无法实现
	- 读
- 写者:
	- 有人在读吗? p(reader)
	- 有人在写吗? (获取写权限) p(write)
	- 有人在写 v(mutexr_w)
	- 写

## 答案分析-读程序优先
- #注意 从简单到复杂,如从一读一写到多读一写 #z408 
- #注意 P是获取资源并上锁
- 设置了一个**计数器 count** 用来记录当前正在访问共享文件的**读**进程数 
	- 每进入一个读进程 count++
	- 当count=1时 上锁p(rw) 防止写入
		- 即当count>1时无需再进行资源请求
- 写者
	- p(rw) 获取访问资源并上锁
	- 写
	- v(rw)
- #注意 由于可能出现对下图中的执行次序,即由于尚未对count++,两个进程连续执行了两次p(rw),从而导致阻塞
	- **设置mutex信号**,在p(mutex)与v(mutex)之间互斥访问,从而只有count++后才会再次执行p(rw)

![](attachments/%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%202022-09-25%2019.32.23.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%202022-09-25%2019.32.23.excalidraw.md)%%
- #注意 **会发生饥饿现象**,有读进程就不能写

## 答案分析-(读写公平法)
- #注意 有读进程正在读,**有写进程请求访问**,会禁止后续读操作请求,按照先来先服务原则工作
![](attachments/%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%202022-09-25%2019.39.19.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%202022-09-25%2019.39.19.excalidraw.md)%%