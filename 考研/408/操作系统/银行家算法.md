# 银行家算法
- **什么是银行家算法**
	- 银行家算法是荷兰学者 Dijkstra 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于**避免死锁**。
	- #z408 **不能**用于判断系统==是否处于死锁==
- **银行家算法的核心思想**
	- 在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进 入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。
- **资源分配向量**
	- **对于每个进程**
		- 已知:最大需求,已分配
		- 计算:**最多还需要**
		- ![](attachments/Pasted%20image%2020220926115810.png)
	- **对于整个系统**
		- 已知:资源总数 
		- 计算:剩余可用资源
## 银行家算法步骤
## 发生事件
某进程Pi向系统申请资源,给不给?
### 需要预先定义的数据结构
- 长度为 m 的一维数组 **Available** 表示还有多少可用资源
	- ![](attachments/Pasted%20image%2020220926121241.png)
- 用长度为 m 的一位数组 **Request** 表示进程Pi此次申请的**各种资源数** 
	- ![](attachments/Pasted%20image%2020220926121320.png)
- $n*m$ 矩阵 **Max** 表示**各进程**对资源的**最大需求数**
- $n*m$ 矩阵 **Allocation** 表示已经给各进程**分配了多少资源**
- $n*m$的$Max – Allocation = Need$ 矩阵表示各进程**最多还需要多少资源**
	- ![](attachments/Pasted%20image%2020220926121342.png)

### 银行家算法步骤
- 检查此次申请是否超过了**该进程之前声明的最大需求数**
	- 超过,认为出错
		- 如需要2个,请求3个
- 检查此时系统剩余的可用资源是否还**能满足这次请求**
	- 无足够资源,则该进程必须等待
- **试探着**分配，更新数据
	- 并非真的分配，修改数值只是为了做预判,进入T0时刻,进行安全性判定 #注意
	- 更新当前可用资源Available,更新已分配Allocation,更新最多还需要Need
- 用**安全性算法**检查此次分配**是否会导致系统进入不安全状态**,即**假定分配后t0时刻**的安全状态.
	- [[安全序列与安全状态]]
	- 设工作向量Work=当前可用资源向量Available
		- Work向量,**每回收一个进程的资源后**会更新
	- 检查**当前的剩余可用资源Work**是否能满足**某个**进程的**最大需求$Need[i]$**，如果可以，就把该进程加入安全序列， 并把该进程持有的资源**全部回收**,并更新Work。
		- #注意 计算时无需先给资源,再全部回收
	- 不断重复上述过程，看最终是否能让**所有进程**都加入安全序列。
	- ![](attachments/%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%202022-09-26%2014.39.14.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%202022-09-26%2014.39.14.excalidraw.md)%%
- **判定分配/让等待**
	- **可找到一个安全序列**。因此,系统是安全的,可以立即将P1所申请的资源分配给它。
	- 可用资源Available,已不能满足任何进程的需要,因此系统**进入不安全状态**,因此拒绝P0的请求,让P0等待,并将Available, Allocationo, Need**恢复为之前的值。**