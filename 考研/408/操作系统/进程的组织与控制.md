# tips

# 进程的组成部分
- 进程控制块(PCB)
- 程序段
- 数据段

[进程控制块PCB](进程控制块PCB.md)

### 组织各进程的PCB的方式
![](attachments/Pasted%20image%2020220921193856.png)
#### 链接方式
![](attachments/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%202022-09-21%2019.40.12.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%202022-09-21%2019.40.12.excalidraw.md)%%
#### 索引方式
![](attachments/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%202022-09-21%2019.40.30.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%202022-09-21%2019.40.30.excalidraw.md)%%
## 程序段
- **概念**
	- 能够被进程调度程序调度到CPU执行的程序代码段
- **注意**
	- 程序可被多个进程共享 #注意 
## 数据段
- 可以是进程对应的程序加工处理的原始数据,也可以是中间或最终结果

# 进程控制
## tips
### 通用操作
- 更新PCB
	- #注意 **修改进程状态state** 
		- ==必然发生==
	- 保存/恢复运行环境
- PCB插入队列
- 分配/回收资源

## 一些概念
### 进程控制
- 主要功能是对系统的**所有进程**实施有效的管理
- 用**原语**实现 #注意 包括创建新进程,撤销已有进程,实现进程状态转换等功能
![](attachments/Pasted%20image%2020220921200600.png)
### 原语
- 进程控制用的**程序段** #疑问 
- 执行过程中**不允许中断**,是一个不可分割的基本单位 #注意 
- 可以用 “**关中断指令**”和“**开中断指令**”这两个特权指令实现原子性
	- CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”
	- ![](attachments/Pasted%20image%2020220921194512.png)

## 进程的创建
- 一个**父进程**创建==一个==子进程 #z408 
	- 父进程和子进程共享**一部分资源**
	- 父进程和子进程==不共享==**虚拟地址空间**
	- 可以并发执行
- 操作系统的操作
	- 申请空白进程控制块
	- 初始化进程控制块
	- 设置进制状态为==就绪态== #z408 
- Linux的==fork==系统调用可以**创建新进程**
### 什么情况下会引发进程创建
![](attachments/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8E%A7%E5%88%B6%202022-09-21%2019.52.01.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8E%A7%E5%88%B6%202022-09-21%2019.52.01.excalidraw.md)%%
### 创建原语
- 操作系统创建一个进程 时使用的原语
- 是操作系统创建一个新进程的过程
![](attachments/Pasted%20image%2020220921194833.png)

## 进程的终止
### 引发进程终止的事件有哪些
- **正常结束**
	- 进程自己请求终止（exit系统调用）
- **异常结束**
	- 整数除以0、非法使用特权指令，然后被操作系统强行杀掉
- **外部干预**
	- Ctrl+Alt+delete，用户选择杀掉进程

### 撤销原语
- 操作系统终止进程的过程
![](attachments/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8E%A7%E5%88%B6%202022-09-21%2019.54.14.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8E%A7%E5%88%B6%202022-09-21%2019.54.14.excalidraw.md)%%
## 进程的阻塞和唤醒
### Tips
- 阻塞原语与唤醒原语必须成对使用 
- 阻塞原语是进程**自身**的一种**主动行为** #注意
	- 只有==运行态==的进程才能转为阻塞态 #注意 #z408 

### 引起阻塞的事件
- 等待某资源
	- 进程申请临界资源
- **等待输入输出完成** #z408 #注意
	- ==进程从磁盘读文件==
![](attachments/Pasted%20image%2020220921195833.png)
### 阻塞原语
运行态->阻塞态
![](attachments/Pasted%20image%2020220921195722.png)
### 引起唤醒的事件
![](attachments/Pasted%20image%2020220921195846.png)
### 唤醒原语
阻塞态->**就绪态**
![](attachments/Pasted%20image%2020220921195730.png)

## 进程的切换
- **怎么切换回之前的进程**?
	- 在进程切换时先在PCB中保存这个进程的运行环境 （保存一些必要的寄存器信息）
		- **进程上下文（Context** ）
	- 当原来的进程再次投入运行时，可以通过PCB恢复它的运行环境
![](attachments/Pasted%20image%2020220921200117.png)