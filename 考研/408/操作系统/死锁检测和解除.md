# Tips

# 死锁的检测与解除
- 如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种 情况下，系统应当提供两个算法：
	- ①**死锁检测算法**：用于检测系统状态，以确定系统中**是否发生**了死锁。 
	- ②**死锁解除算法**：当认定系统中已经发生了死锁，利用该算法可将系统**从死锁状态中解脱**出来。
## 死锁检测
- **怎么进行死锁检测**
	- ①用某种数据结构来**保存资源的请求和分配信息**；
		- 进程节点与资源节点
		- **请求**申请资源边
		- 已经**分配**资源边
		- ![](attachments/Pasted%20image%2020220926145109.png)
		- #注意 **一条边代表一个资源请求/分配**
		- ![](attachments/Pasted%20image%2020220926145141.png)
	- ②提供一种**算法**，利用上述信息来**检测**系统是否已进入死锁状态。
		- **死锁定理**：如果某时刻系统的资源分配图是**不可完全简化**的，那么此时系统死锁 #注意
			- 用死锁检测算法化简资源分配图后，**还连着边的那些进程**就是死锁进程
			- #注意 出现环路,表明满足循环等待,==可能==死锁
				- #注意 每种资源**只有一个**,又出现了环路,是死锁的充分条件,==一定==死锁
			- 没出现环路,表明不满足循环等待,一定不死锁
			- 每个进程节点至少一条请求边,无法判定死锁
		- 找出**既不阻塞又不是孤点**的进程 Pi
			- 请求资源数量小于**空闲**资源数量
		- 消去它所有的请求边和分配边，使之成为==孤立的结点==,并释放资源 #注意
			- 在上图中， P1 是满足这一条件的进程结点，于是将P1的所有边消去
			- ![](attachments/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4%202022-09-26%2015.00.24.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4%202022-09-26%2015.00.24.excalidraw.md)%%
## 死锁解除
- **资源剥夺法**。
	- 挂起（暂时放到外存上）某些死锁进程，并**抢占它的资源**，将这些资源分配给其他的死锁进程。
	- 但是应防止被挂起的进程长时间得不到资源而饥饿。 
- **撤销进程法**（或称**终止进程法**）。
	- 强制**撤销**部分、甚至全部死锁进程，并剥夺这些进程的资源。
		- 哪部分?
		- ![](attachments/Pasted%20image%2020220926150634.png)
	- 这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。 
- **进程回退法**。
	- 让一个或多个死锁进程**回退到足以避免死锁的地步**。
	- 这就要求系统要记录进程的历史信息，设置还原点