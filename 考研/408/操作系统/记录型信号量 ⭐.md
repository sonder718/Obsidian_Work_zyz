## 记录型信号量 ⭐
- 整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用**记录型数据结构表示的信号量**。
	- 注：若考试中出现 P(S)、V(S) 的操作，除非特别说明，否则默认 S 为记录型信号量。 #注意
- **PV操作**
	- #注意 ==不是==系统调用
	- 一对原语
		- wait(S) 原语和 signal(S) 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，**括号里的信号量 S 其实就是函数调用时传入的一个参数。**
	- wait、signal 原语常简称为 **P、V操作**
		- wait(S)、signal(S) 也可以记为 P(S)、V(S)，这对原语可用于实现**系统资源的“申请”和“释放**”
	- PV操作必须互斥访问的原因 #z408 
		- 信号量S是被==多个进程共享==的变量,多个进程都可以通过wait 和signal进行读写操作
###### P 操作
- P( S ) —— ==申请==一个资源S，如果资源不够就阻塞等待 
- 对信号量 S 的一次 P 操作意味着**进程请求一个单位的该类资源**
	- S.value 的初值表示**系统中某种资源的数目。**
	- 因此需要执行 **S.value--，表示资源数减1**
	- 当 S.value **< 0** 时表示该类资源**已分配完毕**，因此进程应调 用 block 原语进行**自我阻塞**（当前运行的进程从运行态->==阻塞态==），**主动放弃处理机**，并插入该类资源的**等待队列** S.L 中。 #注意
		- 可见，该机制遵循了“**让权等待**”原则， 不会出现“忙等”现象。
###### V 操作
 - V( S ) —— ==释放==一个资源S，如果有进程在等待该资源，则唤醒一个进程
- 信号量 S 的一次 V 操作意味着**进程释放一个单位的该类资源**
	- 因此需要执行 **S.value++**，表示资源数加1
	- 若加1后仍是 S.value **<= 0**，表示依然有进程在等待该类 资源，因此应调用 wakeup 原语唤醒**等待队列**中的第一个进程（被唤醒进程从阻塞态->==就绪态==,等待CPU分配）。
		- 🐱即进程释放了一个资源,并将其给等待队列中的第一个进程,而由于等待队列的进程变少了,S.value++
		- 🐱S.value=1,进程①P(S),S.value=0,此时0个进程等待,0个资源剩余,进程②P(S),S.value=-1,此时1个进程等待,0个资源剩余.进程①V(S),S.value=0,资源给等待队列队头的进程②,此时0个进程等待,0个资源剩余
		- #注意 此处是<=0,当**S.value=0,-1,-2**也要进行wakeup唤醒进程
		- #注意 释放了一个资源,唤醒的不是当前进程,而是**等待队列中的第一个进程**
![](attachments/%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%202022-09-23%2020.37.41.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%202022-09-23%2020.37.41.excalidraw.md)%%
