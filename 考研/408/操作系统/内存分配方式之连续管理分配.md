## 内存分配方式之连续管理分配
- 用户程序在主存中是连续的
### 单一连续分配
- 在单一连续分配方式中，内存被分为系统区和用户区。
	- 系统区通常位于内存的低地址部分，用于存放操作系统 相关数据；
	- 用户区用于存放用户进程相关数据。 
		- 内存中只能有**一道**用户程序，用户程序独占整个用户区 空间。
### 固定分区分配
- 将整个用户空间划分为若干个固定大小的分区，在 每个分区中只装入一道作业
- **分类**
	- **分区大小相等**
		- 缺乏灵活性，但是很适合用于用一台计 算机控制多个相同对象的场合（比如：钢铁厂有n个相 同的炼钢炉，就可把内存分为n个大小相等的区域存放 n个炼钢炉控制程序)
	- **分区大小不等**
		- 增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分 （比如：划分多个小分区、适量中等分区、少量大分区)
	- ![](attachments/Pasted%20image%2020220926202356.png)
- **分区说明表**
	- 操作系统需要建立一个数据结构——**分区说明表**，来实现各个分区的分配与回收。
	- 每个表项对应一个分区，通常按分区大小排列。每个表项包括对应**分区的大小、起始地址、状态**（是否已分配）。
- **分配分区的方式**
	- 当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表， 从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状 态为“已分配”
- **优点**：实现简单，**无外部碎片**。
- **缺点**：a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b. 会产生**内部碎片**，内存利用率低。
### 动态分区分配
- 动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是**在进程==装入内存==时，根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。 #注意
	- 因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…）
- **所用数据结构**
	- 空闲分区表
	- 空闲分区链
	- ![](attachments/Pasted%20image%2020220926203103.png)
- **当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？**
	- 按照[[动态分区分配算法]]
- **如何进行分区的分配与回收操作**？
	- 假设系统采用的数据结构是“空闲分区表”
	- **分配**
		- **[动态分区分配算法](动态分区分配算法.md)**
	- **回收**
		- 情况一：回收区的后面有一个相邻的空闲分区
			- 两个相邻的空闲分区合并为一个
		- 情况二：回收区的前面有一个相邻的空闲分区
			- 两个相邻的空闲分区合并为一个
		- 情况三：回收区的前、后各有一个相邻的空闲分区
			- 三个相邻的空闲分区合并为一个
		- 情况四：回收区的前、后都没有相邻的空闲分区
			- 新增一个表项
- **优缺点**
	- 动态分区分配没有内部碎片，但是**有外部碎片**。
		- 可以通过**紧凑（拼凑,拼接，Compaction）技术**来解决外部碎片 #注意
	- 内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。
	- 外部碎片，是指内存中的某些空闲分区由于太小而难以利用。
<!--SR:!2022-10-15,3,250-->