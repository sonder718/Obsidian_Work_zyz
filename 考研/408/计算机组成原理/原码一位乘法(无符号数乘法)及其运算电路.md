### Tip
- 乘法指令可以通过加法和移位指令实现,编译器将乘法运算转换成循环实现
### 原码一位乘法(无符号数乘法)
**特点:** 
- 符号位与数值位分开求
- 符号位异或求得
- 数值部分看做无符号数,采用绝对值相乘  
**输入:**  
$[X]原=x_{s}x_{1}x_{2}..x_{n}$  
$[Y]原=y_{s}y_{1}y_{2}..y_{n}$

**中间变量:**
- 部分积:初值为0,乘数的每一位yi乘被乘数X后,将该结果**与部分积累加**

**过程:**
- 符号位异或运算
- **部分积**分为**高位部分积**和**低位部分积**两部分
	- 高位部分积初始为0
	- 低位部分积初始为==乘数== #注意
- 从==乘数==的yn开始判断 
	- **yn=1**
		- 则**高位部分积**加**被乘数|x|**
		- 部分积==整体==**逻辑右移**一位,最低位丢弃 #注意 每一次相加都要右移
	- **yn=0**
		- 则**高位部分积**加**0**
		- 部分积==整体==**逻辑右移**一位,最低位丢弃

**注意:**
- 部分积可能大于1
	-  但并未溢出,因而部分积和被乘数采用==双符号位==.  #注意
- ![](attachments/Pasted%20image%2020221207122728.png)

### 无符号数乘法运算电路
- **部件:**(32位)
	- 被乘数寄存器X
		- 存放被乘数
	- 乘积寄存器P
		- 32位初始为0
		- 乘积寄存器P初始时置0
	-  乘数寄存器Y
		- 32位,存放乘数
		- 每次右移移出的最低位作送到**控制逻辑**用于==判断被乘数是否加到部分积== #408x  #注意
	- 寄存器PY
		- 64位,连接P与Y,两者可以**一起右移**
	- 进位位C
		- 存放进位
		- 部分积和被乘数X做无符号数加法时,可能产生进位,因此需要一个专门的进位位C
	- 控制逻辑计数器$C_{n}$
		- 计数器C,初值为==32==,每循环一次减1
		- **作用** #z408 
			- 控制循环次数
			- 控制加法和移位
	- 32位ALU
		- ALU是乘法器核心部件,对**乘积寄存器P**和**被乘数寄存器X**的内容做“==无符号加法==”运算,运算结果送回**寄存器P**,进位存放在进位位C中
		- 每次循环都对进位位C、乘积寄存器P和乘数寄存器Y实现**同步“逻辑右移”**
			- 此时,进位位C移入寄存器P的最高位,寄存器Y的最低位移出
- ![](attachments/Pasted%20image%2020221207122211.png)