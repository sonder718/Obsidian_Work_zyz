### 补码一位乘法(Booth算法)
**注意:**
- 符号位参与运算,运算的数都用==补码==表示

**输入:**  
$[X]补=x_{s}x_{1}x_{2}..x_{n}$  
$[Y]补=y_{s}y_{1}y_{2}..y_{n}$  
求$X*Y$

**过程:**
- 提前准备$[x]补,[-x]补,[y]补$的值 #注意
- 乘数末位设附加位$y_{n+1}$,初值为0
- 部分积和被乘数 x 采用**双符号位**.乘数y采用单符号位
- 根据 **(yn,yn+1)** 的取值来确定操作 #注意
| yn | yn+1 | 操作 |  
| --- | ---- | ------------------------- |  
| 0 | 0 | 部分积右移一位 |  
| 0 | 1 | 部分积加$[x]补$,右移一位 |  
| 1 | 0 | 部分积加$[-x]补$,右移一位 |  
| 1 | 1 | 部分积右移一位 |  

**举例:**
- x=-0.1101,y=0.1011,求$x*y$
- $[x]补=11.0011,[-x]补=00.1101,[y]补=0.1011$
- 乘数末位设附加位0即 **乘数Y**=0.1011 0 ,**部分积P**=00.0000
- Y=0.1011 0 ,0-1=-1,P加$[-x]补$,P=00.1101,右移,P=00.0110,Y=10.101 1
> #疑问 是P的最后一位移到的Y的首位吗?
- Y=10.0101 1,1-1=0.P不变=00.0110,右移,P=00.0011,Y=010.10 1
- Y=010.10 1,1-0=1,P加$[x]补$,P=11.0110,右移,P=11.1011,Y=0010.1 0
- Y=0010.1 0,0-1=-1,P加$[-x]补$,P=00.1000,右移,P=00.0100,Y=00010.1
- Y=00010.1,0-1-0=1,P加$[x]补$,P=11.0111
> 最后一次不再右移 #注意
- 得$[X*Y]补=P连接Y=1.0111 0001$
- #注意 **进行n+1次累加,n次右移**,N位补码,乘积为2N+1位
- ![](attachments/Pasted%20image%2020220821222704.png)
### 补码乘法运算电路
**特点:**
- ==不需要==专门的进位位 #注意
- 乘积寄存器P与乘数寄存器Y进行同步的==算数右移== #注意 
	- 因此可能补0可能补1
- #z408 带符号整数乘法下,如前==33==位非全0 或==非全1==,则溢出,OP=1
- ![](attachments/Pasted%20image%2020221207122153.png)