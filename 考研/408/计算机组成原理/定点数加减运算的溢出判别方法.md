
**通过溢出判断电路实现**  
**溢出出现的情景:** 两符号相同的数相加 或 两符号不同的数相减  
**上溢:** 只有“正数+正数”才会上溢——正+正=负  
**下溢:** 只有“负数+负数”才会下溢——负+负=正
##### 采用一位符号位(模2补码)
**输入:** 数A的符号$A_{S}$,数B的符号$B_{S}$,运算结果的符号$C_{S}$  
**核心:** 参与运算的两个数符号相同,且与运算结果的符号不同  
**溢出逻辑表达式**:P42

##### 采用双符号位(模4补码)
**核心:** 运算结果的==两个==符号位$S_{s1}S_{s2}$相同表示未溢出,**不同**则表示溢出  
$S_{s1}S_{s2}$**不同运算情况:**
🐱11,11+11,11=111,10,不溢出 #z408 
**溢出逻辑表达式:**==异或运算==  
**注意:** 
- 实际存储时只存储==1个==符号位，当将两个模四补码送往**ALU**运算时会复制一个符号位,即只在==ALU==中采用双符号位 #注意
- 高位代表真正符号,低位参加移位操作,判断是否发生溢出


##### 采用一位符号位根据数据位的进位情况判断
**输入:** 符号位的进位$C_{s}$ ,最高==数==位的进位$C_{1}$  
**核心:** 两者==相同==表示**没有溢出**,不同表示溢出  
**分类:** 01代表上溢,10代表下溢
>🐱 1,11+1,11=1,10 此时溢出了,为何Cs=1,C1=1  #思考迷雾  
> 补码1,11是-1  
> -1-1=-2=1,10 **实际上没有溢出,只是看上去令人误解为溢出**

>🐱-8-9 = -17,果断是溢出的。补码表示  
1，1000  
1，0111  
=0，1111  
得到的数字是+1.  
符号位发生了进位。但数据位的运算并没有进位。是**下溢**

> 补码X0.X1左移时,如果X0≠X1,则根据双符号位的溢出判断,为溢出


#### 判断运算是否会溢出
- **注意存储器的表达范围**:8位寄存器即8位补码能表达-128到127
- **将16进制转换为10进制**,计算10进制的乘除结果是否在表达范围内
- 如r3=90H,r2=F2H,判断$r2*r3是否会溢出$