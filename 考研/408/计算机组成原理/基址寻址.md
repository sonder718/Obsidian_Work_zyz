### 基址寻址
#### 特点
- 基址寻址:以**程序的起始存放地址**作为“起点”
- 将CPU中**基址寄存器(BR)** 的内容加上**指令格式中的形式地址A**,而形成操作数的有效地址
	- 即EA=(BR)+A。
	- #z408  基址寄存器(BR)中的内容可以看做==无符号数==,形式地址A则用==补码==表示,因此在手工运算时,先将补码A转换为==真值==,再进行运算.
		- 🐱形式地址A用补码表示为FF12H,基址寄存器的内容为F000 0000H
		- 则FF12H转为真值为-00EE,则**有效地址**为==EFFFFF12==
- #注意 操作系统中的==重定位寄存器==是基址寄存器
- **基址寄存器的选择**
	- 可以是专用寄存器,也可以是通用寄存器
- **基址寄存器内容怎么确定?**
	- 由用户决定哪个寄存器作为基址寄存器时，但其内容仍由==操作系统==确定，程序员==不可以==修改BR的内容。 #疑问 操作系统怎么确定
- 在**程序执行过程**中，**基址寄存器的内容不变**（作为基地址)，**形式地址可变**（作为偏移量)。
- **要用几个bit来指明寄存器？**
	- 根据通用寄存器总数判断—— 比如一共有8个，那么就2^3=8，故 3bit。
- **优点**
	- 便于程序“浮动”，可用于编制**浮动程序**（整个程序在内存里边的浮动)。
	- 可**扩大寻址范围**（基址寄存器的位数大于形式地址A的位数)；由于A本来比较短，但是在R中内容比较大，就可以跟着范围变大。
		-  #注意 不能用于缩短指令中地址段的位数
	-  用户不必考虑自己的程序存于主存的哪一空间区域，故方便实现**多道程序并发**运行，**因为主存中可以有多个程序同时存在**。 #注意
#### 执行过程
执行主存中的一段从100起始的代码
```c
int a=2 ,b=3,c=1,y=0;
void main() {
	y=a*b+c;
}
```
![](%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%202022-09-14%2020.32.05.excalidraw.svg)
%%[🖋 Edit in Excalidraw](%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%202022-09-14%2020.32.05.excalidraw.md)%%