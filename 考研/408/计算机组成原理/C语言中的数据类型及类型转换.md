
# C语言中的整数类型及类型转换
- #z408 ==long== 和int都是4个字节,==long long ==才是8个字节
![](attachments/Pasted%20image%2020220823191523.png)
## 有符号数与无符号数的转换
**核心:** 强制类型转换保持==位==值不变,改变解释这些位的方式
**举例:** 
```c
int main()
{
short x=-4321;
unsigned short y=(unsigned short) x;
print("x=d%,y=u%",x,y);
}
```
**输出:** x=-4321,y=61215
>  %d              十进制有符号整数   
    %u              十进制无符号整数
    %f              浮点数   
	%ld   表示输出long整数

**内部原理:**
61215的二进制真值为:1110,1111,0001,1111
-4321的原码表示为:1001,0000,1110,0001
-4321的⭐补码表示为:1110,1111,0001,1111  #注意 补码!
==位值不变== 

**举例2:**
同理unsigned short x=65535 (2^16-1)转为short 即 ==-1==
#注意 #z408 此处容易忽略转换后的是一个**负数**的**补码**,因而还要将其转为原码,易被误解为-32767

## 不同字长整数之间的转换
**核心:** 
- 大字长变量->小字长变量,多余的高位直接截断,低位直接赋值
- 小字长变量->大字长变量,无符号整数进行**零扩展**,有符号整数进行**符号扩展**

**注意:**
- #注意 char类型是8位无符号整数,转int直接补零
- ⭐int+short时会将short强行转换为int

#疑问 关于浮点数的数据转换,精度丢失和不确定性问题 P58

# 浮点数类型
- float转int会发生0截断,即仅保留整数部分.
- **强制类型转换**:常见char->int->long->**double**和float->double,转换过程没有损失
-  #注意 **int到float也没有损失吗**?
	- 对于`int`转`float`来说，可能会有有效数字舍去的风险
	- int是精确到32位的整数,float只保存到1+23=24位
	- int型最大值2147483647
	- float型只能精确保存7位
	- 因此对于int型变量x=758,(int)(float)x=758成立
- **int到double不会有损失**
- #注意 float+double
	- 对于float型变量f=1.5678E3,double型变量d=1.5E100,**(f+d)-d不等于f**,等于0
	- 由于需要**对阶**,f变为0.0....{接近95位}5678E100,对于float型变量,只能保存24位尾数,因而f变为0
 