##### 建立一棵B树
###### B树节点的数据结构
- ![](attachments/Pasted%20image%2020221030214025.png)
```c++
int *keys; // 存储关键字的数组
int t;  // 最小度 (定义一个结点包含关键字的个数 t-1 <= num <= 2t -1) 
BTreeNode **C; // 存储孩子结点指针的数组
int n;  // 记录当前结点包含的关键字的个数
bool leaf; // 叶子结点的一个标记，如果是叶子结点则为true,否则false
```
###### 插入节点
- B-树的插入操作是一种主动插入算法，因为在插入新的关键字之前，我们会将**所有**==已满的结点进行拆分== #注意 #408x 
- 拆分自根到最终插入节点路径上的**所有已满节点**
	- 初始化 `x` 作为根结点
	- 当 `x` 不是叶子结点，执行如下操作：
		-   找到 `x` 的下一个要被访问的孩子结点 `y`
		-   如果 `y` 没有满，则将结点 `y` 作为新的 `x`
		-   如果 `y` 已经满了，拆分 `y` ，结点 `x` 的指针指向结点 `y` 的两部分。 如果 `k` 比 `y` 中间的关键字小， 则将 `y` 的第一部分作为新的 `x` ，否则将 `y` 的第二部分作为新的 `x` ，当将 `y` 拆分后，将 `y` 中的一个关键字==移动到它的父结点== `x` 当中。 #408x  #注意
			- 即==中间结点向上移==
	- 当 `x` 是==叶子结点==时，第二步结束； #注意 #408x 
- ==叶子节点==`x` 必定至少有一个额外的关键字空间，进行**简单的插入**即可。
	- 由于我们已经提前拆分了所有结点
	- 未必不可以出现路线上连续满的结点,如
		- ![](attachments/Pasted%20image%2020221105232028.png)
- ![](attachments/%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91B%E6%A0%91%202022-11-05%2011.35.58.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91B%E6%A0%91%202022-11-05%2011.35.58.excalidraw.md), and the [dark exported image](attachments/%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91B%E6%A0%91%202022-11-05%2011.35.58.excalidraw.dark.svg)%%