##### 堆排序算法的思想
- 将待排序的序列构造成一个**最大堆**，此时序列的==最大值==为根节点 
	- [[堆-一种父子节点间有大小关系的完全二叉树]]
	- [[如何由一个无序序列建成一个堆]]
- 将**根节点**与**末尾元素**进行交换，此时末尾就为**最大值**。
- 然后将**剩余n-1个元素**重新构造成一个堆，这样会得到n个元素的次小值。
	- [[如何在输出堆顶元素之后，调整剩余元素成为一个新的堆]]
- 如此往复，最终得到一个递增序列
	- [[堆的插入操作]]
##### 堆排序适用场景
- 堆排序适合**关键字较多**的情况。
- 🐱在1亿个数中选出前100个最大值? ^s8310p
	- 首先使用一个**大小为100的数组**，读入前100个数，建立小顶堆
	- 而后**依次读入余下的数**
		- 若==小于堆顶则舍弃==
		- 否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数即为所求。
##### 堆排序算法的性能分析
- 空间效率
	- 仅使用了常数个辅助单元，所以空间复杂度为==O(1)==
- **时间效率**
	- 建堆时间为O(n)，之后有n-1次向下调整操作，每次调整的时间复杂度为Oh)
	- 故在最好、最坏和平均情况下，堆排序的时间复杂度为$O(nlog_2n)$。
- **稳定性**
	- 不稳定