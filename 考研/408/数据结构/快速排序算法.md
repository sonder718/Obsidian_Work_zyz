##### 快速排序的核心思想
- **分而治之**
##### 快速排序的算法步骤
-  从要排序的数据中取一个数为“**基准数**pivot”
	- 通常取首元素
- 通过一趟排序将要排序的数据分割成独立的两部分
	- 左边的数据都比“基准数”小,右边的数据都比“基准数”大
	- ![](attachments/Pasted%20image%2020221127171520.png)
- 然后再按步骤2对这两部分数据**分别进行**快速排序
- 整个排序过程可以**递归**进行，以此达到整个数据变成有序序列。
- ![](attachments/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%202022-11-27%2016.52.44.excalidraw.svg)%%[🖋 Edit in Excalidraw](attachments/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%202022-11-27%2016.52.44.excalidraw.md), and the [dark exported image](attachments/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%202022-11-27%2016.52.44.excalidraw.dark.svg)%%
##### 复杂度分析
- **空间复杂度**
	- 由于递归栈
	- 最好$O(log_2{n})$
	- 最坏$O(n)$
	- 平均$O(log_2{n})$
- **时间复杂度**
	- 最好$O(n\log_{2}n)$
	- 平均$O(n\log_{2}n)$
	- 最坏$O(n^2)$
		- 初始序列已经==有序==
		- 两个区域分别包含0和n-1个元素
		- 改进方式
			- 枢纽选头,尾,中间的中位数
	- 是所有内部排序算法中**平均性能最优**的算法 #注意 
- **稳定性**
	- 不稳定