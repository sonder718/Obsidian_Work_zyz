##### K增加时,循环内部归并效率的降低
- 如果毫无限度地增加 k 值，虽然会减少读写外存数据的次数，但会**增加内部归并的时间**
	- 对于 10 个临时文件
		- 当采用 2-路平衡归并时，若每次从 2 个文件中想得到一个最小值时只需比较 1 次；
		- 而采用 5-路平衡归并时，若每次从 5 个文件中想得到一个最小值就需要比较 4 次。
		- 以上仅仅是得到一个最小值记录，如要得到整个临时文件，其耗费的时间就会相差很大。
			- 得出一个最小值即完成了一位排序
- 为了避免在增加 k 值的过程中影响内部归并的效率，在进行 k-路归并时可以使用“**败者树**”来实现，该方法在增加 k 值时不会影响其内部归并的效率
	- 即总的归并效率与k==无关== #注意
##### 败者树与胜者树
- **胜者树**
	- 叶子到根的过程中，每一层都要和**兄弟**进行比较，然后把**胜者**付赋给**父节点**
	- 因为树中每个**非终端结点**（除叶子结点之外的其它结点）中的值都表示的是左右孩子相比较后的**较小值**（==谁最小即为胜者==）,**胜利者**则继续同其它的胜者去比较
	- ![](attachments/Pasted%20image%2020221205222643.png)
- **败者树**
	- 是树形选择排序的一种变形，本身是一棵**完全二叉树**。
	- **败者树高度** #注意
		- $[log_{2}k]+1$
	- **排序码比较次数** #注意 
		- $[log_{2}k]$
	- 败者树中的非终端结点存储的是**失败**的一方,而==胜利者==则继续同其它的胜者去比较 #注意
		- 从叶子到根的过程中，每一层只需和**父节点**进行比较（该叶子更新前可以胜出，所有其常胜 —— 所以其各级父节点保管的必然是与其竞争并失败的兄弟节点），然后**败者**赋给父节点，胜者继续向上走
	- ![](attachments/%E8%B4%A5%E8%80%85%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%86%85%E9%83%A8%E5%BD%92%E5%B9%B6%202022-12-05%2022.32.56.excalidraw.svg)%%[🖋 Edit in Excalidraw](attachments/%E8%B4%A5%E8%80%85%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%86%85%E9%83%A8%E5%BD%92%E5%B9%B6%202022-12-05%2022.32.56.excalidraw.md), and the [dark exported image](attachments/%E8%B4%A5%E8%80%85%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%86%85%E9%83%A8%E5%BD%92%E5%B9%B6%202022-12-05%2022.32.56.excalidraw.dark.svg)%%
		- 如图 2 所示为一棵 5-路归并的败者树，其中 b0—b4 为树的叶子结点，分别为 5 个归并段中**存储的记录的关键字**。
		- ls 为一维数组，表示的是非终端结点，其中存储的数值表示第几归并段（例如 b0 为第 0 个归并段）。ls[0] 中存储的为**最终的胜者**，表示当前第 3 归并段中的关键字最小。因此**输出**b3[0]=6
			- 为了防止在归并过程中某个归并段变为空：可以在每个归并段**最后附加一个关键字为最大值的记录**。这样当某一时刻选出的冠军为最大值时，表明 5 个归并段已全部归并完成。（因为只要还有记录，最终的胜者就不可能是附加的最大值
