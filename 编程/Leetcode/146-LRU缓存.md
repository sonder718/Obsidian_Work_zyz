- ![](attachments/Pasted%20image%2020230102224933.png)
- ![](attachments/Pasted%20image%2020230102224950.png)
##### 我的思路
- 首先考虑用什么保存缓存中的关键字
- 因为关键字是唯一的,为了方便获取关键字,采用Map来实现关键字的保存Map<int,int> 即<key,元素值>
	- #注意 不能是int,只能是Integer ![](attachments/Pasted%20image%2020230102230433.png)
- 由于有缓存大小上限,类内设置当前关键字数c_keynum;Map大小等于c_keynum时,不能put
- 为实现LRU算法,保存Map_tim<int,int>即<key,最近访问时间>,每put一下,所有关键字时间++;
	- 或许可以使用sorted_set 有没有这种数据结构?
- **缺点**
	- 能够正确执行,但速度太慢
	- 似乎是更新tim_map的耗时过多?
	- ![](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-02%2023.50.50.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-02%2023.50.50.excalidraw.md), and the [dark exported image](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-02%2023.50.50.excalidraw.dark.svg)%%
- **改进**
	- 本质上是要实现一个==LinkedHashMap==
	- 即包含put和get函数，并且在空间满了时能够按最近访问进行淘汰
	- ![](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-07%2021.53.28.excalidraw.svg)%%[🖋 Edit in Excalidraw](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-07%2021.53.28.excalidraw.md), and the [dark exported image](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-07%2021.53.28.excalidraw.dark.svg)%%
- **改进思路**
	- 更新时间太慢了![](attachments/Pasted%20image%2020230107234153.png)
	- 不采取记录时间的方式，而是按照访问次序，将Key值链接起来。当访问时，根据hashmap得到key对应value值。❌但是这样难以更新链表节点
	- 进一步，当访问时
		- 根据hashmap得到key对应链表节点指针thisone
			- ![](attachments/Pasted%20image%2020230113201923.png)
			- ![](attachments/Pasted%20image%2020230113201938.png)
		- 根据链表节点指针thisone得到对应value值。
			- ![](attachments/Pasted%20image%2020230113202018.png)
			- ![](attachments/Pasted%20image%2020230113202042.png)
		- 并且将该节点移动到链表头部
			- 设置**头指针**,更新双向链表,head->next即最近访问节点
			- ![](attachments/Pasted%20image%2020230113202124.png)
			- ![](attachments/Pasted%20image%2020230113202136.png)
