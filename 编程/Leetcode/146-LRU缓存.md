- ![](attachments/Pasted%20image%2020230102224933.png)
- ![](attachments/Pasted%20image%2020230102224950.png)
##### 我的思路
- 首先考虑用什么保存缓存中的关键字
- 因为关键字是唯一的,为了方便获取关键字,采用Map来实现关键字的保存Map<int,int> 即<key,元素值>
	- #注意 不能是int,只能是Integer ![](attachments/Pasted%20image%2020230102230433.png)
- 由于有缓存大小上限,类内设置当前关键字数c_keynum;Map大小等于c_keynum时,不能put
- 为实现LRU算法,保存Map_tim<int,int>即<key,最近访问时间>,每put一下,所有关键字时间++;
	- 或许可以使用sorted_set 有没有这种数据结构?
- **缺点**
	- 能够正确执行,但速度太慢
	- 似乎是更新tim_map的耗时过多?
	- ![](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-02%2023.50.50.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-02%2023.50.50.excalidraw.md), and the [dark exported image](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-02%2023.50.50.excalidraw.dark.svg)%%
- **改进**
	- 本质上是要实现一个==LinkedHashMap==
	- 即包含put和get函数，并且在空间满了时能够按最近访问进行淘汰
	- ![](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-07%2021.53.28.excalidraw.svg)
%%[🖋 Edit in Excalidraw](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-07%2021.53.28.excalidraw.md), and the [dark exported image](attachments/146-LRU%E7%BC%93%E5%AD%98%202023-01-07%2021.53.28.excalidraw.dark.svg)%%