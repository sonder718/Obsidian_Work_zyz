##### 问题描述
- ![](attachments/Pasted%20image%2020230114232123.png)
##### 总体思路
- 建立大小为K的小根堆,堆顶即为第K大元素
	- Java中采用优先队列PriorityQueue可默认实现最小堆
		- ![](attachments/Pasted%20image%2020230114232318.png)
		- 如要实现最大堆,则需重载compare
			- ![](attachments/Pasted%20image%2020230114232420.png)
- 遍历,如果i>堆顶,则转换并调整堆
	- ![](attachments/Pasted%20image%2020230114232448.png)
	- 类似[在内存有限的情况下统计文本文件中出现次数最多的5个字符串](../工作相关/在内存有限的情况下统计文本文件中出现次数最多的5个字符串.md)
- ![](attachments/Pasted%20image%2020230114232516.png)
- **缺点**
	- O(nlogk),速度相比之下不太快
##### 改进1
- 类似快速排序
	- [快速排序算法](../../考研/408/数据结构/快速排序算法.md)
- 选择枢纽后,进行partition(l,r)划分,将枢纽交换到新位置
	- ![](attachments/Pasted%20image%2020230115225200.png)
	- 如果该位置i=k
		- 则返回该位置的元素
	- 如果该位置i>k
		- 证明第k大的元素在左边
		- 对左边进行划分 partition(l,i)
	- 如果该位置i< k
		- 证明第k大的元素在右边
		- 对右边进行划分
- 划分partition的具体方式是左右指针逐渐向中间靠拢
	- 提前保存枢纽元素
	- l移动到都第一个小于枢纽的数处,则l左边的数都比枢纽大
	- r同理
	- **此时l处小于枢纽,r处大于枢纽,交换lr两者后都符合要求**
	- ![](attachments/Pasted%20image%2020230115224940.png)