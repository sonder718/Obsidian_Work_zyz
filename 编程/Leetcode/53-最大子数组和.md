# 题目描述
- ![500](attachments/Pasted%20image%2020230204154842.png)

# 最朴素的想法-无后效性-动态规划
- 能不能只走一遍,把所有连续子数组的和保存?
	- ❌连续子数组数量太多
- 能不能只走一遍 `for(int i=0;i<n;i++)`
	- ❌把以**第i个元素为首**的最大和连续子数组保存
		- 无法计算后面的元素和
		- 即**有后效性**
	- 把以**第i个元素为尾**的最大和连续子数组保存
		- ✔==只保存最大和==
		- -2,1,-3,4,-1,2,1,-5,4走一遍变成
		- -2,1,==-2==,4,==3==,==5==,==6==,==1==,==5==
			- 更新第i个数时,用到的==之前计算出的信息==
			- **状态转移方程**![](attachments/Pasted%20image%2020230204164946.png)
			- ![](attachments/Pasted%20image%2020230204164513.png)
		- 即每次都会分成两个组 |**已计算出最大连续子数组**|**还未计算**|`
>为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。

# 分而治之
- **一次猜测**❌
	- 如果一个连续子数组的和为x
	- 会出现如下几种情况
		- 和他的邻居的和相加 和变大
			- 合并
		- 和他的邻居的和相加 和变小
			- 如再和他邻居的邻居相加 和变比自身大
				- 合并
			- 否则
				- 不合并
	- **问题**:从谁开始?
- **对于一个区间**
	- ![](attachments/Pasted%20image%2020230204170137.png)
- **合并两个区间**
	- ![](attachments/Pasted%20image%2020230204170235.png)
- **递归分治**
	- 将大区间划分成诸多小区间
	- 长度为1的区间,四个属性都方便计算
	- 不断合并长度为1的区间
		- 根据小区间的属性合并大区间
	- ![](attachments/Pasted%20image%2020230204170324.png)