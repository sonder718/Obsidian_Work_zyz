## 层次
- **Synchronized**是关键字，内置语言实现,是**不可中断锁**
	- 易用,高效
- **Lock**需要手动加锁和手动解锁，一般通过 lock.lock() 方法来进行加锁， 通过 lock.unlock() 方法进行解锁
	- 灵活,可控
	- **ReetrantLock** 实现了Lock接口，它是一个**可重入锁**，内部定义了公平锁与非公平锁。
	- **ReadWriteLock** 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。
		- **ReentrantReadWirteLock**实现了ReadWirteLock接口，并未实现Lock接口
## 面对异常
- synchronized在发生异常时候会**自动释放占有的锁**，因此不会出现死锁；
- 而lock发生异常时候，不会主动释放占有的锁，必须**手动unlock来释放锁**，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，**finally中写入unlock**，避免死锁的发生。）

## 内部实现具体区别
- **synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。** 
	- 独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。
- Lock用的是**乐观锁方式**。
	- 所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swap）
## 优劣
- Lock可以通过trylock来知道**有没有获取锁**，而synchronized不能
- 当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的**性能**要远远优于synchronized

## ReetrantLock的使用情景
- 某个线程在等待一个锁的控制权的这段时间需要中断(**可中断锁**) `lockInterruptibly()`
	- 不可中断锁的问题是，当出现“异常”时，只能一直阻塞等待
	- 中断锁可以在等待一定时间之后，主动的中断线程 2，以解决线程阻塞等待的问题
- ![](attachments/Pasted%20image%2020230221120621.png)