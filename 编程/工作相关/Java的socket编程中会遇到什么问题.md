# TCP的粘包和半包问题
- 因为 TCP 是面向连接的传输协议，TCP 传输的数据是以流的形式，而**流数据**是没有明确的开始结尾边界，所以 TCP 也**没办法判断哪一段流属于一个消息**
- **场景**
	- 服务器端用来接收消息；
	- 客户端用来发送一段固定的消息。
	- ![](attachments/Pasted%20image%2020230227002736.png)
## 粘包的主要原因：
-   发送方每次写入数据 < 套接字（Socket）缓冲区大小；
-   接收方读取套接字（Socket）缓冲区数据不够及时。
## 半包的主要原因：
-   发送方每次写入数据 > 套接字（Socket）缓冲区大小；
-   发送的数据大于协议的 MTU (Maximum Transmission Unit，最大传输单元)，因此必须拆包。
## 解决方式
- 使用 Java 中自带的 `BufferedReader` 和 `BufferedWriter`，也就是带缓冲区的输入字符流和输出字符流，通过写入的时候加上 `\n` 来结尾，读取的时候使用 `readLine` 按行来读取数据，这样就知道流的边界了，从而解决了粘包和半包的问题
- **客户端**
	- ![](attachments/Pasted%20image%2020230227002554.png)
- **服务端**
	- ![](attachments/Pasted%20image%2020230227002619.png)